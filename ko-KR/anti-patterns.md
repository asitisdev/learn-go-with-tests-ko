# TDD 안티패턴

때때로 TDD 기법을 검토하고 피해야 할 행동을 상기시키는 것이 필요합니다.

TDD 프로세스는 개념적으로 따르기 쉽지만, 수행하면서 설계 기술에 도전하게 될 것입니다. **이것을 TDD가 어렵다고 착각하지 마세요. 설계가 어려운 것입니다!**

이 챕터는 여러 TDD 및 테스트 안티패턴과 해결 방법을 나열합니다.

## TDD를 전혀 하지 않기

물론 TDD 없이도 훌륭한 소프트웨어를 작성할 수 있지만, 코드 설계와 테스트 품질에서 본 많은 문제는 TDD에 대한 규율 있는 접근 방식이 사용되었다면 도달하기 매우 어려웠을 것입니다.

TDD의 강점 중 하나는 문제를 분해하고, 달성하려는 것을 이해하고(빨강), 완료하고(녹색), 올바르게 만드는 방법에 대해 잘 생각하는(파랑/리팩토링) 공식적인 프로세스를 제공한다는 것입니다.

이것 없이 프로세스는 종종 임시적이고 느슨하여 엔지니어링을 *있을 수 있는 것보다* 더 어렵게 *만들 수* 있습니다.

## 리팩토링 단계의 제약에 대한 오해

저는 많은 워크숍, 모빙 또는 페어링 세션에서 누군가가 테스트를 통과시키고 리팩토링 단계에 있는 것을 보았습니다. 생각 후에 코드를 새 구조체로 추상화하는 것이 좋겠다고 생각합니다; 초보 현학자가 소리칩니다:

> 이렇게 할 수 없어요! 먼저 이것에 대한 테스트를 작성해야 해요, 우리는 TDD를 하고 있잖아요!

이것은 일반적인 오해인 것 같습니다. **테스트가 녹색이면 코드에 원하는 것을 할 수 있으며**, 허용되지 않는 유일한 것은 **동작을 추가하거나 변경하는 것**입니다.

이러한 테스트의 요점은 *리팩토링할 자유*를 주고, 올바른 추상화를 찾고 코드를 변경하고 이해하기 쉽게 만드는 것입니다.

## 실패하지 않는 테스트 (또는 상록수 테스트)

이것이 얼마나 자주 발생하는지 놀랍습니다. 일부 테스트를 디버깅하거나 변경하기 시작하고 깨닫습니다: 이 테스트가 실패할 수 있는 시나리오가 없습니다. 또는 적어도 테스트가 *보호해야 하는* 방식으로 실패하지 않습니다.

**첫 번째 단계**를 따르면 TDD에서 이것은 *거의 불가능*합니다,

> 테스트를 작성하고 실패하는 것을 확인

이것은 거의 항상 개발자가 코드가 작성된 *후에* 테스트를 작성하거나 유용한 테스트 스위트를 만드는 것이 아닌 테스트 커버리지를 쫓을 때 수행됩니다.

## 쓸모없는 어설션

시스템에서 작업한 적이 있고 테스트를 깨뜨린 다음 이것을 볼 수 있습니까?

> `false was not equal to true`

false가 true와 같지 않다는 것을 알고 있습니다. 이것은 도움이 되는 메시지가 아닙니다; 무엇을 깨뜨렸는지 알려주지 않습니다. 이것은 TDD 프로세스를 따르지 않고 실패 오류 메시지를 읽지 않는 증상입니다.

기본으로 돌아가서,

> 테스트를 작성하고 실패하는 것을 확인하세요 (그리고 오류 메시지를 부끄러워하지 마세요)

## 관련 없는 세부 정보에 대한 어설션

이것의 예는 실제로 테스트에서 관심 있는 것은 필드 중 하나의 값뿐인데 복잡한 객체에 대해 어설션하는 것입니다.

```go
// 이렇게 하지 마세요, 이제 테스트가 전체 객체에 긴밀하게 결합됩니다
if !cmp.Equal(complexObject, want) {
	t.Error("got %+v, want %+v", complexObject, want)
}

// 구체적으로 하고 결합을 느슨하게 하세요
got := complexObject.fieldYouCareAboutForThisTest
if got != want {
	t.Error("got %q, want %q", got, want)
}
```

추가 어설션은 문서에서 '노이즈'를 생성하여 테스트를 읽기 더 어렵게 만들 뿐만 아니라 관심 없는 데이터와 테스트를 불필요하게 결합합니다. 이것은 객체의 필드를 변경하거나 동작 방식을 변경하면 테스트에서 예기치 않은 컴파일 문제나 실패가 발생할 수 있음을 의미합니다.

이것은 빨간 단계를 충분히 엄격하게 따르지 않는 예입니다.

- 기존 설계가 **원하는 동작에 대해 생각하기보다는** 테스트를 작성하는 방법에 영향을 미치도록 하기
- 실패하는 테스트의 오류 메시지에 충분한 고려를 하지 않기

## 단위 테스트에 대한 단일 시나리오 내에서 많은 어설션

많은 어설션은 테스트를 읽기 어렵게 만들고 실패할 때 디버깅하기 어렵게 만들 수 있습니다.

다른 것에 대해 어설션하기 위해 동일한 끔찍한 설정을 복제하는 것을 꺼려서 테스트 설정이 복잡할 때 특히 점진적으로 들어옵니다. 이 대신 새로운 것에 대해 어설션하기 어렵게 만드는 설계의 문제를 수정해야 합니다.

유용한 경험 법칙은 테스트당 하나의 어설션을 목표로 하는 것입니다. Go에서 필요할 때 어설션 사이를 명확하게 구분하기 위해 서브테스트를 활용하세요. 이것은 동작 대 구현 세부 정보에 대한 어설션을 분리하는 편리한 기법이기도 합니다.

설정이나 실행 시간이 제약이 될 수 있는 다른 테스트(예: 웹 브라우저를 구동하는 인수 테스트)의 경우 약간 까다로운 디버깅 테스트의 장단점을 테스트 실행 시간에 대해 비교해야 합니다.

## 테스트에 귀 기울이지 않기

[Dave Farley의 "When TDD goes wrong" 동영상](https://www.youtube.com/watch?v=UWtEVKVPBQ0&feature=youtu.be)에서 지적합니다,

> TDD는 설계에 대해 가능한 가장 빠른 피드백을 제공합니다

제 경험에서 많은 개발자가 TDD를 연습하려고 하지만 TDD 프로세스에서 돌아오는 신호를 자주 무시합니다. 그래서 그들은 여전히 취약하고 짜증나는 시스템과 좋지 않은 테스트 스위트에 갇혀 있습니다.

간단히 말해서, 코드를 테스트하기 어려우면 코드를 *사용하기* 어렵습니다. 테스트를 코드의 첫 번째 사용자로 취급하면 코드가 작업하기 좋은지 아닌지 알 수 있습니다.

이 책에서 많이 강조했고 다시 말하겠습니다 **테스트에 귀 기울이세요**.

### 과도한 설정, 너무 많은 테스트 더블 등

흥미로운 일이 일어나기 전에 20, 50, 100, 200줄의 설정 코드가 있는 테스트를 본 적이 있습니까? 그런 다음 코드를 변경하고 엉망을 다시 방문하면서 다른 직업을 가졌으면 좋겠다고 생각합니까?

여기서 신호는 무엇입니까? *귀 기울이세요*, 복잡한 테스트 `==` 복잡한 코드. 왜 코드가 복잡합니까? 그래야 합니까?

- 테스트에 많은 테스트 더블이 있으면 테스트하는 코드에 많은 종속성이 있음을 의미합니다 - 이것은 설계에 작업이 필요하다는 것을 의미합니다.
- 테스트가 모의 객체와의 다양한 상호 작용 설정에 의존하면 코드가 종속성과 많은 상호 작용을 하고 있다는 것을 의미합니다. 이러한 상호 작용이 더 간단할 수 있는지 스스로에게 물어보세요.

#### 누수가 있는 인터페이스

많은 메서드가 있는 `interface`를 선언했다면 누수 추상화를 가리킵니다. 이상적으로 하나인 더 통합된 메서드 집합으로 해당 협력을 정의할 수 있는 방법에 대해 생각하세요.

#### 인터페이스 오염

Go 속담에서 말하듯이, *인터페이스가 클수록 추상화가 약해집니다*. 패키지 사용자에게 거대한 인터페이스를 노출하면 테스트에서 전체 API와 일치하는 스텁/모의 객체를 만들도록 강제하고, 사용하지 않는 메서드에 대한 구현도 제공합니다(때때로 사용하면 안 된다는 것을 명확히 하기 위해 패닉합니다). 이 상황은 [인터페이스 오염](https://rakyll.org/interface-pollution/)이라는 안티패턴이며 표준 라이브러리가 작은 인터페이스만 제공하는 이유입니다.

대신 패키지에서 모든 관련 메서드가 내보내진 베어 구조체를 노출하고, API 클라이언트에게 필요한 메서드의 하위 집합에 대해 추상화하는 자체 인터페이스를 선언할 자유를 남겨야 합니다: 예: [go-redis](https://github.com/redis/go-redis)는 API 클라이언트에게 구조체(`redis.Client`)를 노출합니다.

일반적으로 클라이언트에게 인터페이스를 노출해야 하는 경우는 다음과 같습니다:
- 인터페이스가 작고 일관된 함수 집합으로 구성됩니다.
- 인터페이스와 구현이 분리되어야 합니다(예: 사용자가 여러 구현 중에서 선택하거나 외부 종속성을 모킹해야 하기 때문).

#### 사용하는 테스트 더블 유형에 대해 생각하세요

- 모의 객체는 때때로 도움이 되지만 매우 강력하므로 오용하기 쉽습니다. 대신 스텁을 사용하는 제약을 주세요.
- 스파이로 구현 세부 정보를 확인하는 것은 때때로 도움이 되지만 피하려고 노력하세요. 구현 세부 정보는 일반적으로 중요하지 않으며 가능하면 테스트를 결합하고 싶지 않습니다. 테스트를 **부수적인 세부 정보가 아닌 유용한 동작**에 결합하세요.
- 테스트 더블의 분류법이 약간 불분명하면 [테스트 더블의 이름을 올바르게 지정하는 것에 대한 게시물을 읽어보세요](https://quii.dev/Start*naming*your*test*doubles_correctly)

#### 종속성 통합

웹사이트의 새 사용자 등록을 처리하는 `http.HandlerFunc`에 대한 코드가 있습니다.

```go
type User struct {
	// 일부 사용자 필드
}

type UserStore interface {
	CheckEmailExists(email string) (bool, error)
	StoreUser(newUser User) error
}

type Emailer interface {
	SendEmail(to User, body string, subject string) error
}

func NewRegistrationHandler(userStore UserStore, emailer Emailer) http.HandlerFunc {
	return func(writer http.ResponseWriter, request *http.Request) {
		// 요청 본문에서 사용자 추출 (오류 처리)
		// 사용자 존재 확인 (중복, 오류 처리)
		// 사용자 저장 (오류 처리)
		// 확인 이메일 작성 및 전송 (오류 처리)
		// 여기까지 왔으면 2xx 응답 반환
	}
}
```

첫 번째 패스에서 설계가 그렇게 나쁘지 않다고 말하는 것이 합리적입니다. 2개의 종속성만 있습니다!

핸들러의 책임을 고려하여 설계를 재평가하세요:

- 요청 본문을 `User`로 파싱 :white*check*mark:
- `UserStore`를 사용하여 사용자가 존재하는지 확인 :question:
- `UserStore`를 사용하여 사용자 저장 :question:
- 이메일 작성 :question:
- `Emailer`를 사용하여 이메일 전송 :question:
- 성공, 오류 등에 따라 적절한 http 응답 반환 :white*check*mark:

이 코드를 실행하려면 다양한 정도의 테스트 더블 설정, 스파이 등으로 많은 테스트를 작성해야 합니다

- 요구 사항이 확장되면? 이메일 번역? SMS 확인도 보내기? 이 변경을 수용하기 위해 HTTP 핸들러를 변경해야 하는 것이 합리적입니까?
- "이메일을 보내야 함"이라는 중요한 규칙이 HTTP 핸들러 내에 있는 것이 맞습니까?
    - 그 규칙을 확인하기 위해 HTTP 요청을 만들고 응답을 읽는 의식을 거쳐야 하는 이유는 무엇입니까?

**테스트에 귀 기울이세요**. TDD 방식으로 이 코드에 대한 테스트를 작성하면 빠르게 불편함을 느끼게 될 것입니다(또는 적어도 당신 안의 게으른 개발자가 짜증을 낼 것입니다). 고통스러우면 멈추고 생각하세요.

대신 설계가 이렇다면 어떨까요?

```go
type UserService interface {
	Register(newUser User) error
}

func NewRegistrationHandler(userService UserService) http.HandlerFunc {
	return func(writer http.ResponseWriter, request *http.Request) {
		// 사용자 파싱
		// 사용자 등록
		// 오류 확인, 응답 전송
	}
}
```

- 핸들러 테스트가 간단함 ✅
- 등록 관련 규칙 변경이 HTTP에서 격리되어 테스트도 더 간단함 ✅

## 캡슐화 위반

캡슐화는 매우 중요합니다. 패키지의 모든 것을 내보내지(또는 공개하지) 않는 이유가 있습니다. 긴밀한 결합을 피하기 위해 작은 표면적을 가진 일관된 API를 원합니다.

사람들은 때때로 무언가를 테스트하기 위해 함수나 메서드를 공개하려는 유혹을 받습니다. 이렇게 하면 설계가 나빠지고 코드의 유지 관리자와 사용자에게 혼란스러운 메시지를 보냅니다.

이것의 결과는 개발자가 테스트를 디버깅하려고 시도하다가 결국 테스트되는 함수가 *테스트에서만 호출된다는* 것을 깨닫는 것입니다. 이것은 명백히 **끔찍한 결과이며 시간 낭비입니다**.

Go에서 테스트를 작성하기 위한 기본 위치를 *패키지의 소비자 관점에서*로 고려하세요. 테스트 패키지(예: `package gocoin_test`)에 테스트가 있도록 하여 이것을 컴파일 타임 제약으로 만들 수 있습니다. 이렇게 하면 패키지의 내보낸 멤버에만 접근할 수 있으므로 구현 세부 정보에 결합할 수 없습니다.

## 복잡한 테이블 테스트

테이블 테스트는 테스트 설정이 동일하고 입력만 다르게 하고 싶을 때 여러 시나리오를 실행하는 좋은 방법입니다.

*하지만* 하나의 영광스러운 테이블을 갖는다는 명목 하에 다른 종류의 테스트를 억지로 끼워 맞추면 읽고 이해하기 지저분해질 수 있습니다.

```go
cases := []struct {
	X                int
	Y                int
	Z                int
	err              error
	IsFullMoon       bool
	IsLeapYear       bool
	AtWarWithEurasia bool
}{}
```

테이블 `struct`에 새 필드와 부울을 추가하는 것보다 **테이블에서 벗어나 새 테스트를 작성하는 것을 두려워하지 마세요**.

소프트웨어를 작성할 때 명심해야 할 것은,

> [단순함은 쉽지 않습니다](https://www.infoq.com/presentations/Simple-Made-Easy/)

테이블에 필드를 "그냥" 추가하는 것은 쉬울 수 있지만 상황을 단순함과는 거리가 멀게 만들 수 있습니다.

## 요약

단위 테스트의 대부분의 문제는 일반적으로 다음으로 추적할 수 있습니다:

- TDD 프로세스를 따르지 않는 개발자
- 좋지 않은 설계

따라서 좋은 소프트웨어 설계에 대해 배우세요!

좋은 소식은 TDD가 처음에 말했듯이 *설계 기술을 향상시키는 데* 도움이 될 수 있다는 것입니다:

**TDD의 주요 목적은 설계에 대한 피드백을 제공하는 것입니다.** 백만 번째로 테스트에 귀 기울이세요, 그것들은 설계를 반영하고 있습니다.

테스트가 주는 피드백에 귀 기울여 테스트의 품질에 대해 정직하면 더 나은 개발자가 될 것입니다.
