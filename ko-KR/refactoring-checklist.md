# 리팩토링 단계, 시작 체크리스트

리팩토링은 충분히 연습하면 대부분의 경우 자연스럽게 상당히 쉬워지는 기술입니다.

이 활동은 종종 더 큰 설계 변경과 혼동되지만, 별개입니다. 리팩토링과 다른 프로그래밍 활동을 구분하는 것이 도움이 되는데, 명확성과 규율을 가지고 작업할 수 있기 때문입니다.

## 리팩토링 vs 다른 활동

리팩토링은 기존 코드를 개선하는 것이며 <u>동작을 변경하지 않습니다</u>; 따라서 테스트를 변경할 필요가 없어야 합니다.

이것이 TDD 사이클의 3단계인 이유입니다. 동작을 추가하고 이를 뒷받침하는 테스트를 작성한 후, 리팩토링은 테스트 코드를 변경할 필요가 없는 활동이어야 합니다. **동시에 테스트를 변경해야 하면서 일부 코드를 "리팩토링"하고 있다면 다른 일을 하고 있는 것입니다**.

많은 매우 유용한 리팩토링은 배우기 쉽고 수행하기 쉽습니다(IDE가 거의 전적으로 자동화합니다) 그러나 시간이 지남에 따라 시스템의 품질에 막대한 영향을 미칩니다.

### 다른 활동, 예를 들어 "큰" 설계

> 그래서 "실제" 동작을 변경하지 않지만 테스트를 변경해야 합니까? 그게 뭡니까?

타입에서 작업하고 코드의 품질을 개선하고 싶다고 합시다. **리팩토링은 테스트를 변경할 필요가 없어야 합니다**, 따라서 다음을 할 수 없습니다:

- 동작 변경
- 메서드 시그니처 변경

...테스트가 이 두 가지에 결합되어 있기 때문입니다, 하지만 다음을 할 수 있습니다:

- 프라이빗 메서드, 필드 및 심지어 새 타입 & 인터페이스 도입
- 공개 메서드의 내부 변경

메서드의 시그니처를 변경하고 싶다면?

```go
func (b BirthdayGreeter) WishHappyBirthday(age int, firstname, lastname string, email Email) {
	// 흥미로운 이메일 코드
}
```

인수 목록이 너무 길다고 느끼고 코드에 더 많은 응집력과 의미를 가져오고 싶을 수 있습니다.

```go
func (b BirthdayGreeter) WishHappyBirthday(person Person)
```

글쎄요, 이제 **설계**하고 있으며 신중하게 밟아야 합니다. 규율을 가지고 하지 않으면 코드, 그 뒤의 테스트, **그리고** 아마도 그것에 의존하는 것들을 엉망으로 만들 수 있습니다 - 기억하세요, 테스트만 `WishHappyBirthday`를 사용하는 것이 아닙니다. 바라건대 "실제" 코드에서도 사용됩니다!

**여전히 테스트를 먼저 사용하여 이 변경을 주도할 수 있어야 합니다**. 이것이 "동작" 변경인지에 대해 머리카락을 나눌 수 있지만, 메서드가 다르게 동작하기를 원합니다.

이것은 동작 변경이므로 여기서도 TDD 프로세스를 적용하세요. TDD의 이점 중 하나는 시스템에서 동작 변경을 주도하는 간단하고 안전하며 반복 가능한 방법을 제공한다는 것입니다; **느낌이** 다르다고 해서 이러한 상황에서 그것을 포기하는 이유는 무엇입니까?

이 경우, 새 타입을 사용하도록 기존 테스트를 변경할 것입니다. 위험을 줄이고 규율과 명확성을 가져오기 위해 TDD에서 일반적으로 하는 반복적이고 작은 단계가 이러한 상황에서도 도움이 될 것입니다.

`WishHappyBirthday`를 호출하는 여러 테스트가 있을 가능성이 있습니다; 이러한 시나리오에서 하나를 제외한 모든 테스트를 주석 처리하고, 변경을 주도한 다음, 적합하다고 보이는 대로 나머지 테스트를 처리하는 것을 권장합니다.

### 큰 설계

설계는 더 큰 변경과 더 광범위한 대화를 요구할 수 있으며 일반적으로 주관성의 수준이 있습니다. 시스템 일부의 설계를 변경하는 것은 일반적으로 리팩토링보다 더 긴 프로세스입니다; 그럼에도 불구하고 작은 단계로 수행하는 방법에 대해 생각하여 위험을 줄이도록 노력해야 합니다.

### 숲을 보지 못하고 나무만 보기

> [영국 영어에서 누군가가 **see the wood for the trees** 할 수 없거나, 미국 영어에서 see the forest for the trees 할 수 없다면, 그들은 무언가의 세부 사항에 너무 관여되어 전체에 대해 중요한 것을 알아차리지 못합니다.](https://www.collinsdictionary.com/dictionary/english/cant-see-the-wood-for-the-trees)

"큰" 설계 문제에 대해 이야기하는 것은 **기본 코드가 잘 인수분해되어 있을 때** 더 쉽습니다. 파일을 열 때마다 당신과 동료가 코드의 엉망을 정신적으로 파싱하는 데 상당한 시간을 보내야 한다면 코드의 설계에 대해 생각할 기회가 있습니까?

이것이 **TDD 프로세스에서 지속적인 리팩토링이 중요한 이유**입니다. 작은 설계 문제를 해결하지 못하면 더 큰 시스템의 전체 설계를 엔지니어링하기 어려울 것입니다.

슬프게도 잘못 인수분해된 코드는 엔지니어가 흔들리는 기초 위에 복잡성을 쌓으면서 기하급수적으로 악화됩니다.

## 시작 정신 체크리스트

**모든 TDD 사이클에서 정신적 체크리스트를 실행하는 습관을 들이세요.** 연습할수록 쉬워집니다. **연습이 필요한 기술입니다.** 이러한 각 변경은 테스트에 변경이 필요하지 않아야 합니다.

동료와 저가 사용하는 IntelliJ/GoLand용 단축키를 포함했습니다. 새 엔지니어를 코칭할 때마다 이러한 도구를 빠르고 안전하게 리팩토링하는 데 사용하는 근육 기억과 습관을 얻으려고 노력하도록 권장합니다.

### 변수 인라인

변수를 만들고 다른 메서드/함수에 전달하기만 한다면:

```go
url := baseURL + "/user/" + id
res, err := client.Get(url)
```

변수 이름이 의미 있는 의미를 추가하지 **않는 한** 인라인하는 것을 고려하세요(`command+option+n`).

```go
res, err := client.Get(baseURL + "/user/" + id)
```

인라인에 **너무** 현명하지 마세요; 목표는 변수가 0이고 대신 아무도 읽을 수 없는 우스꽝스러운 한 줄짜리를 갖는 것이 아닙니다. 값에 의미 있는 이름을 추가할 수 있으면 그대로 두는 것이 가장 좋을 수 있습니다.

### 변수 추출로 값 DRY

"반복하지 마세요"(DRY). 함수에서 같은 값을 여러 번 사용합니까? 의미 있는 변수 이름으로 변수를 추출하고 캡처하는 것을 고려하세요(`command+option+v`).

이것은 가독성에 도움이 되고 같은 값의 여러 항목을 업데이트해야 할 필요가 없으므로 향후 값을 변경하기 쉽게 만듭니다.

### 일반적으로 DRY

[DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)는 요즘 나쁜 평판을 받고 있으며 어느 정도 정당화됩니다. DRY는 피상적인 수준에서 **너무** 이해하기 쉽고 그런 다음 잘못 적용되는 개념 중 하나입니다.

엔지니어는 일부 코드 줄을 절약하기 위해 당혹스럽고 얽힌 추상화를 만들면서 DRY를 너무 멀리 가져갈 수 있습니다. DRY의 **진정한** 아이디어인 한 곳에 **아이디어**를 캡처하는 것 대신. 코드 줄 수를 줄이는 것은 종종 DRY의 부작용이지만, **실제 목표는 아닙니다**.

그래서 네, DRY가 잘못 적용될 수 있지만, 아무것도 DRY하지 않기를 거부하는 극단적인 반대도 나쁩니다. 반복되는 코드는 노이즈를 추가하고 유지 관리 비용을 증가시킵니다. DRY 오용에 대한 두려움으로 관련 개념이나 값을 하나로 모으기를 거부하면 **다른** 문제가 발생합니다.

따라서 "모든 것을 DRY해야 함" 또는 "DRY는 나쁘다"의 어느 쪽에서도 극단주의자가 되기보다는 두뇌를 활용하고 앞에 있는 코드에 대해 생각하세요. 무엇이 반복됩니까? 그래야 합니까? 반복된 코드를 메서드로 캡슐화하면 매개변수 목록이 합리적으로 보입니까? 자기 문서화되고 "아이디어"를 명확하게 캡슐화하는 느낌입니까?

10번 중 9번은 함수의 인수 목록을 보고 지저분하고 혼란스러워 보이면 DRY의 잘못된 적용일 가능성이 높습니다.

일부 코드를 DRY하는 것이 어렵게 느껴지면 아마도 상황을 더 복잡하게 만들고 있습니다; 멈추는 것을 고려하세요.

주의해서 DRY하되, **이것을 자주 연습하면 판단력이 향상됩니다**. 동료들에게 "그냥 해보세요"라고 권장하고 틀리면 소스 컨트롤을 사용하여 안전한 곳으로 돌아가세요.

<u>**이러한 것들을 시도하면 논의하는 것보다 더 많이 배울 것입니다**</u>, 그리고 좋은 자동화된 테스트와 결합된 소스 컨트롤은 실험하고 배울 수 있는 완벽한 설정을 제공합니다.

### "마법" 값 추출

> [설명되지 않은 의미 또는 여러 번 발생하는 고유한 값으로 (가급적) 명명된 상수로 대체될 수 있음](https://en.wikipedia.org/wiki/Magic_number_(programming))

변수 추출(`command+option+v`) 또는 상수(`command+option+c`)를 사용하여 마법 값에 의미를 부여하세요. 이것은 인라인 리팩토링의 역으로 볼 수 있습니다. 저는 종종 무엇이 더 잘 읽히는지 판단하는 데 도움이 되도록 인라인과 추출로 코드를 "토글"합니다.

반복된 값을 추출하면 일정 수준의 **결합**도 추가됩니다. 해당 값을 사용하는 모든 것이 이제 결합됩니다. 다음 코드를 고려하세요:

```go
func main() {
	api1Client := http.Client{
		Timeout: 1 * time.Second,
	}
	api2Client := http.Client{
		Timeout: 1 * time.Second,
	}
	api3Client := http.Client{
		Timeout: 1 * time.Second,
	}
	//등
}
```

애플리케이션을 위해 일부 HTTP 클라이언트를 설정하고 있습니다. 여기에 일부 **마법 값**이 있으며 변수를 추출하고 의미 있는 이름을 지정하여 `Timeout`을 DRY할 수 있습니다.

![변수를 추출하는 스크린샷](https://i.imgur.com/4sgUG7L.png)

이제 코드는 다음과 같습니다

```go
func main() {
	timeout := 1 * time.Second
	api1Client := http.Client{
		Timeout: timeout,
	}
	api2Client := http.Client{
		Timeout: timeout,
	}
	api3Client := http.Client{
		Timeout: timeout,
	}
	// 등..
}
```

더 이상 마법 값이 없습니다; 의미 있는 이름을 지정했지만 세 클라이언트 모두 **동일한 타임아웃을 공유**하도록 만들었습니다. 원하는 것일 **수** 있습니다; 리팩토링은 매우 상황에 따라 다르지만 주의해야 합니다.

IDE를 잘 사용할 수 있으면 **인라인** 리팩토링을 수행하여 클라이언트가 다시 별도의 `Timeout` 값을 갖도록 할 수 있습니다.

### 공개 메서드/함수를 스캔하기 쉽게 만들기

코드에 지나치게 긴 공개 메서드나 함수가 있습니까?

메서드 추출(`command+option+m`) 리팩토링으로 프라이빗 메서드/함수에 단계를 캡슐화하세요.

아래 코드에는 JSON 문자열을 만들고 HTTP 요청에서 `POST`할 수 있도록 `io.Reader`로 변환하는 것과 관련된 지루하고 산만한 의식이 있습니다.

```go
func (ws *WidgetService) CreateWidget(name string) error {
	url := ws.baseURL + "/widgets"
	payload := []byte(`{"name": "` + name + `"}`)

	req, err := http.NewRequest(
		http.MethodPost,
		url,
		bytes.NewBuffer(payload),
	)
	//todo: 코드, err 등 처리
}
```

먼저 인라인 변수 리팩토링(`command+option+n`)을 사용하여 `payload`를 버퍼 생성에 넣습니다.

```go
func (ws *WidgetService) CreateWidget(name string) error {
	url := ws.baseURL + "/widgets"
	req, err := http.NewRequest(
		http.MethodPost,
		url,
		bytes.NewBuffer([]byte(`{"name": "`+name+`"}`)),
	)
	// 등
}
```

이제 메서드 추출 리팩토링(`command+option+m`)을 사용하여 JSON 페이로드 생성을 함수로 추출하여 메서드에서 노이즈를 제거할 수 있습니다.

```go
func (ws *WidgetService) CreateWidget(name string) error {
	url := ws.baseURL + "/widgets"
	req, err := http.NewRequest(
		http.MethodPost,
		url,
		createWidgetPayload(name),
	)
	// 등
}
```

공개 메서드와 함수는 **어떻게** 하는지가 아니라 **무엇**을 하는지 설명해야 합니다.

> **코드가 무엇을 하는지 이해하기 위해 생각해야 할 때마다, 그 이해를 더 즉시 명확하게 만들기 위해 코드를 리팩토링할 수 있는지 스스로에게 묻습니다**

-- Martin Fowler

이것은 전체 설계를 더 잘 이해하는 데 도움이 되며, 책임에 대한 질문을 할 수 있게 합니다:

> 왜 이 메서드가 X를 합니까? 그것은 Y에 있어야 하지 않습니까?

> 왜 이 메서드가 그렇게 많은 작업을 합니까? 다른 곳에서 통합할 수 있습니까?

프라이빗 함수와 메서드는 훌륭합니다; 관련 없는 어떻게를 무엇으로 래핑할 수 있습니다.

#### 하지만 이제 어떻게 작동하는지 모릅니다!

더 작은 함수와 메서드가 다른 것들로 구성되는 것을 선호하는 이 리팩토링에 대한 일반적인 반론은 코드가 어떻게 작동하는지 이해하기 어렵게 만들 수 있다는 것입니다. 이에 대한 저의 무뚝뚝한 대답은

> 도구를 효과적으로 사용하여 코드베이스를 탐색하는 방법을 배웠습니까?

`CreateWidget`의 **작성자**로서 저는 특정 문자열 생성이 메서드 서술에서 본질적인 캐릭터가 되기를 원하지 않습니다. 99%의 경우 독자에게 산만하고 관련 없는 노이즈입니다.

그러나 누군가 **관심**이 있다면 `createWidgetPayload`에서 `command+b`(또는 "심볼로 이동"이 무엇이든 간에)를 누르고... 읽습니다. 다시 돌아가려면 `command+left-arrow`를 누릅니다.

### 값 생성을 생성 시간으로 이동

메서드는 종종 이전 `CreateWidget` 메서드의 `url`처럼 값을 생성하고 사용해야 합니다.

```go
type WidgetService struct {
	baseURL string
	client  *http.Client
}

func NewWidgetService(baseURL string) *WidgetService {
	client := http.Client{
		Timeout: 10 * time.Second,
	}
	return &WidgetService{baseURL: baseURL, client: &client}
}

func (ws *WidgetService) CreateWidget(name string) error {
	url := ws.baseURL + "/widgets"
	req, err := http.NewRequest(
		http.MethodPost,
		url,
		createWidgetPayload(name),
	)
	// 등
}
```

여기서 적용할 수 있는 리팩토링 기법은 **메서드의 인수에 의존하지 않는** 값이 생성되고 있다면 대신 타입에 **필드**를 만들고 생성자 함수에서 계산할 수 있습니다.

```go
type WidgetService struct {
	client          *http.Client
	createWidgetURL string
}

func NewWidgetService(baseURL string) *WidgetService {
	client := http.Client{
		Timeout: 10 * time.Second,
	}
	return &WidgetService{
		createWidgetURL: baseURL + "/widgets",
		client:          &client,
	}
}

func (ws *WidgetService) CreateWidget(name string) error {
	req, err := http.NewRequest(
		http.MethodPost,
		ws.createWidgetURL,
		createWidgetPayload(name),
	)
	// 등
}
```

생성 시간으로 이동하면 메서드를 단순화할 수 있습니다.

#### `CreateWidget` 비교 및 대조

시작

```go
func (ws *WidgetService) CreateWidget(name string) error {
	url := ws.baseURL + "/widgets"
	payload := []byte(`{"name": "` + name + `"}`)
	req, err := http.NewRequest(
		http.MethodPost,
		url,
		bytes.NewBuffer(payload),
	)
	// 등
}

```

거의 전적으로 자동화된 도구를 사용하여 주도된 몇 가지 기본 리팩토링으로 결과는

```go
func (ws *WidgetService) CreateWidget(name string) error {
	req, err := http.NewRequest(
		http.MethodPost,
		ws.createWidgetURL,
		createWidgetPayload(name),
	)
	// 등
}
```

이것은 작은 개선이지만 확실히 더 잘 읽힙니다. 잘 연습하면 이런 종류의 개선은 1분도 채 걸리지 않으며 TDD를 잘 적용했다면 아무것도 깨뜨리지 않도록 테스트의 안전망을 갖게 됩니다. 이러한 지속적인 작은 개선은 코드베이스의 장기적인 건강에 중요합니다.

### 주석을 제거하려고 노력하세요

> 우리가 따르는 휴리스틱은 무언가에 주석을 달아야 할 필요성을 느낄 때마다 대신 메서드를 작성한다는 것입니다.

-- Martin Fowler

다시, 메서드 추출 리팩토링이 여기서 도움이 될 수 있습니다.

## 규칙의 예외

테스트에서 변경이 필요한 코드를 개선할 수 있으며, 규칙을 어기더라도 여전히 "리팩토링" 버킷에 넣을 수 있습니다.

간단한 예는 `shift+F6`으로 공개 심볼(예: 메서드, 타입 또는 함수)의 이름을 변경하는 것입니다. 이것은 물론 프로덕션 코드와 테스트 코드를 변경합니다.

그러나 **자동화되고 안전한** 변경이므로 다른 종류의 **설계** 변경으로 많은 사람들이 빠지는 테스트와 프로덕션 코드를 깨뜨리는 나선에 빠질 위험이 최소화됩니다.

그런 이유로 IDE/편집기로 안전하게 수행할 수 있는 모든 변경은 여전히 기꺼이 리팩토링이라고 부를 것입니다.

## 도구를 사용하여 리팩토링 연습을 돕습니다

- 이러한 작은 변경을 할 때마다 단위 테스트를 실행해야 합니다. 코드를 단위 테스트 가능하게 만드는 데 시간을 투자했으며 몇 밀리초의 피드백 루프가 중요한 이점 중 하나입니다; 사용하세요!
- 소스 컨트롤에 의존하세요. 아이디어를 시도하는 것을 부끄러워하지 마세요. 만족하면 커밋하고, 그렇지 않으면 되돌립니다. 이것은 편안하고 쉽고 큰 일이 아니어야 합니다.
- 단위 테스트와 소스 컨트롤을 더 잘 활용할수록 리팩토링을 **연습**하기가 더 쉬워집니다. 이 규율을 마스터하면 신뢰할 수 있고 효과적인 피드백 루프와 안전망이 있기 때문에 **설계 기술이 빠르게 향상됩니다**.
- 경력에서 너무 자주 개발자들이 리팩토링할 시간이 없다고 불평하는 것을 들었습니다; 불행히도 규율을 가지고 하지 않기 때문에 그렇게 많은 시간이 걸리고 - 충분히 연습하지 않았기 때문입니다.
- 타이핑이 병목 현상이 된 적은 없지만 사용하는 편집기/IDE를 사용하여 안전하고 빠르게 리팩토링할 수 있어야 합니다. 예를 들어 도구가 키 입력으로 변수를 추출할 수 없으면 더 노동 집약적이고 위험하기 때문에 덜 할 것입니다.

## 리팩토링 허락을 구하지 마세요

리팩토링은 작업에서 자주 발생하는 것이어야 하며, 항상 하고 있는 것입니다. 또한 특히 조금씩 자주 하면 시간을 많이 소비하지 않아야 합니다.

리팩토링하지 않으면 내부 품질이 저하되고 팀의 능력이 떨어지고 압박이 증가합니다.

Martin Fowler가 우리에게 또 하나의 환상적인 인용문을 줍니다.

> 그러나 마감일이 매우 가까울 때를 제외하고는 시간이 없다고 리팩토링을 미루어서는 안 됩니다. 여러 프로젝트의 경험에 따르면 리팩토링 세션은 생산성 향상으로 이어집니다. 시간이 충분하지 않은 것은 일반적으로 리팩토링을 해야 한다는 신호입니다.

## 마무리

이것은 방대한 목록이 아니라 시작일 뿐입니다. 프로가 되려면 Martin Fowler의 Refactoring 책(2판)을 읽으세요.

리팩토링은 잘 연습하면 매우 빠르고 안전해야 하므로 하지 않을 변명이 거의 없습니다. 너무 많은 사람들이 리팩토링을 배울 기술이 아닌 다른 사람들이 결정할 것으로 봅니다.

항상 코드를 **모범적인** 상태로 남기도록 노력해야 합니다.

좋은 리팩토링은 이해하기 쉬운 코드로 이어집니다. 코드에 대한 이해는 더 나은 설계를 발견하기 쉽게 만듭니다. 거대한 함수, 불필요하게 중복된 코드, 깊은 중첩 등이 있는 시스템에서 설계를 찾기가 훨씬 어렵습니다. **더 나은 설계를 위해 자주, 작은 리팩토링이 필요합니다**.
