# 단위 테스트가 왜 필요하고 어떻게 활용하는가

[이 주제에 대해 이야기하는 동영상 링크입니다](https://www.youtube.com/watch?v=Kwtit8ZEK7U)

동영상이 싫다면 여기 긴 글 버전이 있습니다.

## 소프트웨어

소프트웨어의 약속은 변경할 수 있다는 것입니다. 그래서 *soft* ware라고 불리며 하드웨어에 비해 유연합니다. 훌륭한 엔지니어링 팀은 회사에 놀라운 자산이 되어야 하며, 비즈니스와 함께 진화하여 가치를 계속 제공할 수 있는 시스템을 작성해야 합니다.

그런데 왜 우리는 그것을 못할까요? 완전히 실패하는 프로젝트에 대해 얼마나 자주 듣습니까? 또는 "레거시"가 되어 완전히 다시 작성해야 합니다 (그리고 재작성도 종종 실패합니다!)

소프트웨어 시스템이 어떻게 "실패"합니까? 올바를 때까지 변경할 수 없습니까? 그것이 우리가 약속받은 것입니다!

많은 사람들이 시스템을 구축하기 위해 Go를 선택하고 있는데, 더 오래 살아남을 수 있기를 바라는 여러 선택을 했기 때문입니다.

- [충분히 목을 매달 수 있는 밧줄이 있다고 설명한](http://www.quii.dev/Scala_-_Just_enough_rope_to_hang_yourself) 이전 Scala 생활과 비교하면, Go는 25개의 키워드만 있고 *많은* 시스템을 표준 라이브러리와 몇 가지 다른 작은 라이브러리로 구축할 수 있습니다. Go로 코드를 작성하고 6개월 후에 돌아와도 여전히 이해가 될 것이라고 희망합니다.
- 테스트, 벤치마킹, 린팅 및 배포 도구는 대부분의 대안에 비해 일류입니다.
- 표준 라이브러리가 훌륭합니다.
- 빠른 피드백 루프를 위한 매우 빠른 컴파일 속도
- Go 하위 호환성 약속. Go가 제네릭과 다른 기능을 미래에 얻을 것 같지만 설계자들은 5년 전에 작성한 Go 코드도 여전히 빌드될 것이라고 약속했습니다. 저는 실제로 프로젝트를 Scala 2.8에서 2.10으로 업그레이드하는 데 몇 주를 보냈습니다.

이 모든 훌륭한 속성에도 불구하고 끔찍한 시스템을 만들 수 있으므로, 언어가 얼마나 빛나든(또는 아니든) 적용되는 소프트웨어 엔지니어링 교훈을 과거에서 배우고 이해해야 합니다.

1974년에 [Manny Lehman](https://en.wikipedia.org/wiki/Manny_Lehman_%28computer_scientist%29)이라는 영리한 소프트웨어 엔지니어가 [Lehman의 소프트웨어 진화 법칙](https://en.wikipedia.org/wiki/Lehman%27s_laws_of_software_evolution)을 작성했습니다.

> 이 법칙은 한편으로는 새로운 개발을 추진하는 힘과 다른 한편으로는 진행을 늦추는 힘 사이의 균형을 설명합니다.

이러한 힘은 레거시가 된 시스템을 배송하고 계속해서 다시 작성하는 끝없는 순환에 빠지지 않으려면 이해해야 할 중요한 것 같습니다.

## 지속적 변경의 법칙

> 현실 세계에서 사용되는 모든 소프트웨어 시스템은 변경되거나 환경에서 점점 덜 유용해집니다

시스템이 변경되어야 하거나 덜 유용해진다는 것은 명백해 보이지만 이것이 얼마나 자주 무시됩니까?

많은 팀이 특정 날짜에 프로젝트를 제공하고 다음 프로젝트로 이동하도록 인센티브를 받습니다. 소프트웨어가 "운이 좋으면" 적어도 유지 관리를 위해 다른 사람들에게 인수인계가 있지만 물론 그들은 작성하지 않았습니다.

사람들은 종종 "빠르게 제공"하는 데 도움이 될 프레임워크를 선택하는 데 관심을 갖지만 시스템이 어떻게 진화해야 하는지에 대한 수명에는 집중하지 않습니다.

당신이 믿을 수 없는 소프트웨어 엔지니어라도 시스템의 미래 요구 사항을 모르는 것의 희생자가 될 것입니다. 비즈니스가 변경됨에 따라 당신이 작성한 훌륭한 코드 중 일부는 이제 더 이상 관련이 없습니다.

Lehman은 70년대에 잘 나가고 있었는데 우리에게 씹을 다른 법칙을 주었습니다.

## 복잡성 증가의 법칙

> 시스템이 진화함에 따라 복잡성을 줄이는 작업을 하지 않으면 복잡성이 증가합니다

그가 여기서 말하는 것은 소프트웨어 팀이 맹목적인 기능 공장이 될 수 없고, 장기적으로 살아남기를 바라며 소프트웨어에 점점 더 많은 기능을 쌓을 수 없다는 것입니다.

도메인에 대한 지식이 변함에 따라 시스템의 복잡성을 계속 관리**해야 합니다**.

## 리팩토링

소프트웨어를 유연하게 유지하는 소프트웨어 엔지니어링의 *많은* 측면이 있습니다:

- 개발자 권한 부여
- 일반적으로 "좋은" 코드. 합리적인 관심사 분리 등
- 커뮤니케이션 능력
- 아키텍처
- 관찰 가능성
- 배포 가능성
- 자동화된 테스트
- 피드백 루프

리팩토링에 집중하겠습니다. "이것을 리팩토링해야 합니다"라는 문구가 많이 던져지는데 - 프로그래밍 첫날 개발자에게 생각 없이 말합니다.

이 문구는 어디서 왔습니까? 리팩토링은 코드 작성과 어떻게 다릅니까?

저와 많은 다른 사람들이 리팩토링을 하고 있다고 *생각*했지만 실수한 것을 알고 있습니다

[Martin Fowler는 사람들이 어떻게 잘못하고 있는지 설명합니다](https://martinfowler.com/bliki/RefactoringMalapropism.html)

> 그러나 "리팩토링"이라는 용어는 적절하지 않을 때 종종 사용됩니다. 누군가가 리팩토링하는 동안 시스템이 며칠 동안 고장 났다고 말하면 리팩토링하지 않고 있다고 확신할 수 있습니다.

그래서 그것은 무엇입니까?

### 인수분해

학교에서 수학을 배울 때 인수분해에 대해 배웠을 것입니다. 매우 간단한 예가 있습니다

`1/2 + 1/4` 계산

이렇게 하려면 분모를 *인수분해*하여 표현식을

`2/4 + 1/4`로 바꾸고 `3/4`로 바꿀 수 있습니다.

여기서 중요한 교훈을 얻을 수 있습니다. *표현식을 인수분해*할 때 **표현식의 의미를 변경하지 않았습니다**. 둘 다 `3/4`와 같지만 작업하기 더 쉽게 만들었습니다; `1/2`를 `2/4`로 변경하면 "도메인"에 더 쉽게 들어맞습니다.

코드를 리팩토링할 때 코드를 더 쉽게 이해하고 시스템이 해야 할 일에 대한 현재 이해에 "맞추는" 방법을 찾으려고 합니다. 결정적으로 **동작을 변경해서는 안 됩니다**.

#### Go 예제

`language`로 `name`에게 인사하는 함수가 있습니다

    func Hello(name, language string) string {

      if language == "es" {
         return "Hola, " + name
      }

      if language == "fr" {
         return "Bonjour, " + name
      }

      // 수십 개 더 많은 언어 상상

      return "Hello, " + name
    }

수십 개의 `if` 문이 있는 것은 좋지 않으며 `, `와 `name`으로 언어별 인사를 연결하는 중복이 있습니다. 그래서 코드를 리팩토링하겠습니다.

    func Hello(name, language string) string {
      	return fmt.Sprintf(
      		"%s, %s",
      		greeting(language),
      		name,
      	)
    }

    var greetings = map[string]string {
      "es": "Hola",
      "fr": "Bonjour",
      //등..
    }

    func greeting(language string) string {
      greeting, exists := greetings[language]

      if exists {
         return greeting
      }

      return "Hello"
    }

이 리팩토링의 본질은 실제로 중요하지 않습니다. 중요한 것은 동작을 변경하지 않았다는 것입니다.

리팩토링할 때 원하는 것을 할 수 있습니다. 인터페이스, 새 타입, 함수, 메서드 등을 추가할 수 있습니다. 유일한 규칙은 동작을 변경하지 않는 것입니다

### 코드를 리팩토링할 때 동작을 변경하면 안 됩니다

이것은 매우 중요합니다. 동시에 동작을 변경하면 *두 가지* 작업을 동시에 수행하는 것입니다. 소프트웨어 엔지니어로서 우리는 시스템을 다른 파일/패키지/함수 등으로 분해하는 것을 배우는데 큰 덩어리를 이해하려고 하는 것이 어렵기 때문입니다.

동시에 많은 것을 생각하고 싶지 않은데 그때 실수를 하기 때문입니다. 개발자들이 감당할 수 있는 것보다 더 많이 물기 때문에 많은 리팩토링 노력이 실패하는 것을 목격했습니다.

수학 수업에서 펜과 종이로 인수분해를 할 때 머리로 표현식의 의미를 변경하지 않았는지 수동으로 확인해야 했습니다. 특히 사소하지 않은 시스템에서 코드로 작업할 때 리팩토링할 때 동작을 변경하지 않는지 어떻게 알 수 있습니까?

테스트를 작성하지 않기로 선택한 사람들은 일반적으로 수동 테스트에 의존합니다. 작은 프로젝트 외에는 이것은 엄청난 시간 낭비가 되고 장기적으로 확장되지 않습니다.

**안전하게 리팩토링하려면 단위 테스트가 필요합니다** 왜냐하면 제공하기 때문입니다

- 동작 변경에 대해 걱정하지 않고 코드를 재구성할 수 있다는 자신감
- 시스템이 어떻게 동작해야 하는지에 대한 인간을 위한 문서
- 수동 테스트보다 훨씬 빠르고 안정적인 피드백

#### Go 예제

`Hello` 함수에 대한 단위 테스트는 다음과 같을 수 있습니다

    func TestHello(t *testing.T) {
      got := Hello("Chris", "es")
      want := "Hola, Chris"

      if got != want {
         t.Errorf("got %q want %q", got, want)
      }
    }

커맨드 라인에서 `go test`를 실행하고 리팩토링 노력이 동작을 변경했는지에 대한 즉각적인 피드백을 받을 수 있습니다. 실제로 에디터/IDE 내에서 테스트를 실행하는 마법 버튼을 배우는 것이 가장 좋습니다.

다음을 수행하는 상태에 들어가고 싶습니다

- 작은 리팩토링
- 테스트 실행
- 반복

토끼굴에 빠지지 않고 실수하지 않도록 매우 빠른 피드백 루프 내에서.

모든 핵심 동작이 단위 테스트되고 1초 미만의 피드백을 제공하는 프로젝트가 있으면 필요할 때 대담한 리팩토링을 수행하는 매우 강력한 안전망입니다. 이것은 Lehman이 설명하는 복잡성의 유입력을 관리하는 데 도움이 됩니다.

## 단위 테스트가 그렇게 좋으면 왜 작성에 저항이 있을까요?

한편으로는 (저처럼) 단위 테스트가 시스템의 장기적인 건강에 중요하다고 말하는 사람들이 있는데 자신 있게 리팩토링을 계속할 수 있도록 보장하기 때문입니다.

다른 한편으로는 단위 테스트가 실제로 리팩토링을 *방해*한 경험을 설명하는 사람들이 있습니다.

스스로에게 물어보세요. 리팩토링할 때 테스트를 얼마나 자주 변경해야 합니까? 수년 동안 저는 매우 좋은 테스트 커버리지를 가진 많은 프로젝트에 있었지만 엔지니어들은 테스트 변경의 인지된 노력 때문에 리팩토링을 꺼려했습니다.

이것은 우리가 약속받은 것과 반대입니다!

### 왜 이런 일이 일어납니까?

정사각형을 개발하라는 요청을 받고 두 삼각형을 붙이는 것이 그것을 수행하는 가장 좋은 방법이라고 생각했다고 상상해 보세요.

![정사각형을 형성하는 두 직각 삼각형](https://i.imgur.com/ela7SVf.jpg)

정사각형 주변에 단위 테스트를 작성하여 변이 같은지 확인한 다음 삼각형 주변에 테스트를 작성합니다. 삼각형이 올바르게 렌더링되는지 확인하고 싶으므로 각도가 180도가 되는지 확인하고, 2개를 만드는지 확인하는 등... 테스트 커버리지가 정말 중요하고 이러한 테스트를 작성하는 것은 꽤 쉬우므로 왜 안 됩니까?

몇 주 후에 지속적 변경의 법칙이 시스템에 닥치고 새로운 개발자가 변경을 합니다. 그녀는 이제 정사각형이 2개의 삼각형 대신 2개의 직사각형으로 형성되는 것이 더 낫다고 믿습니다.

![정사각형을 형성하는 두 직사각형](https://i.imgur.com/1G6rYqD.jpg)

이 리팩토링을 시도하고 여러 실패하는 테스트에서 혼합된 신호를 받습니다. 실제로 여기서 중요한 동작을 깨뜨렸습니까? 이제 이러한 삼각형 테스트를 파고들어 무슨 일이 일어나고 있는지 이해해야 합니다.

*정사각형이 삼각형으로 형성되는 것은 실제로 중요하지 않지만* **테스트가 구현 세부 정보의 중요성을 잘못 높였습니다**.

## 구현 세부 정보보다 동작 테스트 선호

사람들이 단위 테스트에 대해 불평하는 것을 들을 때 종종 테스트가 잘못된 추상화 수준에 있기 때문입니다. 구현 세부 정보를 테스트하고, 협력자에게 과도하게 스파이하고 너무 많이 모킹합니다.

이것은 단위 테스트가 무엇인지에 대한 오해와 허영심 지표(테스트 커버리지) 추구에서 비롯된다고 생각합니다.

동작만 테스트하라고 말하면 시스템/블랙박스 테스트만 작성해야 합니까? 이러한 종류의 테스트는 핵심 사용자 여정을 확인하는 측면에서 많은 가치가 있지만 일반적으로 작성하는 데 비용이 많이 들고 실행 속도가 느립니다. 그 이유로 피드백 루프가 느리기 때문에 *리팩토링*에 그다지 도움이 되지 않습니다. 또한 블랙박스 테스트는 단위 테스트에 비해 근본 원인에 대해 그다지 도움이 되지 않는 경향이 있습니다.

그래서 올바른 추상화 수준은 *무엇*입니까?

## 효과적인 단위 테스트 작성은 설계 문제입니다

잠시 테스트를 잊고 시스템 내에 도메인의 핵심 개념을 중심으로 자체 포함되고 분리된 "단위"가 있는 것이 바람직합니다.

저는 이러한 단위를 더 큰 시스템을 만들기 위해 다른 브릭과 결합할 수 있는 일관된 API가 있는 간단한 레고 브릭으로 상상하는 것을 좋아합니다. 이러한 API 아래에는 필요한 대로 작동하도록 협력하는 수십 개의 것들(타입, 함수 등)이 있을 수 있습니다.

예를 들어 Go로 은행을 작성하는 경우 "account" 패키지가 있을 수 있습니다. 구현 세부 정보를 누출하지 않고 통합하기 쉬운 API를 제공합니다.

이러한 속성을 따르는 이러한 단위가 있으면 공개 API에 대해 단위 테스트를 작성할 수 있습니다. *정의에 따라* 이러한 테스트는 유용한 동작만 테스트할 수 있습니다. 이러한 단위 아래에서 원하는 만큼 구현을 리팩토링할 수 있고 테스트는 대부분 방해가 되지 않아야 합니다.

### 이것이 단위 테스트입니까?

**예**. 단위 테스트는 설명한 것처럼 "단위"에 대한 것입니다. 단일 클래스/함수/무엇이든에 대해서만이 *아니었습니다*.

## 이러한 개념 통합

다뤘습니다

- 리팩토링
- 단위 테스트
- 단위 설계

이러한 소프트웨어 설계 측면이 서로를 강화한다는 것을 알 수 있습니다.

### 리팩토링

- 단위 테스트에 대한 신호를 제공합니다. 수동 검사를 해야 하면 더 많은 테스트가 필요합니다. 테스트가 잘못 실패하면 테스트가 잘못된 추상화 수준에 있습니다(또는 가치가 없고 삭제해야 합니다).
- 단위 내부 및 단위 간의 복잡성을 처리하는 데 도움이 됩니다.

### 단위 테스트

- 리팩토링을 위한 안전망을 제공합니다.
- 단위의 동작을 확인하고 문서화합니다.

### (잘 설계된) 단위

- *의미 있는* 단위 테스트를 작성하기 쉽습니다.
- 리팩토링하기 쉽습니다.

복잡성을 관리하고 시스템을 유연하게 유지하기 위해 코드를 지속적으로 리팩토링할 수 있는 지점에 도달하는 데 도움이 되는 프로세스가 있습니까?

## TDD(테스트 주도 개발)가 왜 필요한가

어떤 사람들은 소프트웨어가 변경되어야 한다는 Lehman의 인용문을 보고 정교한 설계를 과도하게 생각하여 "완벽한" 확장 가능한 시스템을 만들려고 미리 많은 시간을 낭비하고 결국 잘못되어 아무데도 가지 못합니다.

이것은 분석 팀이 6개월 동안 요구 사항 문서를 작성하고 아키텍트 팀이 또 6개월 동안 설계를 하고 몇 년 후에 전체 프로젝트가 실패하는 소프트웨어의 나쁜 옛날입니다.

나쁜 옛날이라고 하지만 이것은 여전히 일어납니다!

애자일은 반복적으로 작업하고, 작게 시작하여 소프트웨어를 진화시켜 소프트웨어의 설계와 실제 사용자와 어떻게 작동하는지에 대한 빠른 피드백을 얻어야 한다고 가르칩니다; TDD는 이 접근 방식을 강제합니다.

TDD는 Lehman이 말하는 법칙과 역사를 통해 배운 다른 교훈을 지속적으로 리팩토링하고 반복적으로 제공하는 방법론을 권장하여 해결합니다.

### 작은 단계

- 원하는 작은 양의 동작에 대한 작은 테스트 작성
- 테스트가 명확한 오류로 실패하는지 확인 (빨강)
- 테스트를 통과시키기 위한 최소한의 코드 작성 (녹색)
- 리팩토링
- 반복

능숙해지면 이 작업 방식은 자연스럽고 빠릅니다.

이 피드백 루프가 그리 오래 걸리지 않을 것으로 예상하고 시스템이 "녹색"이 아닌 상태에 있으면 불안해질 것입니다. 토끼굴에 빠졌을 수 있음을 나타내기 때문입니다.

테스트의 피드백에 편안하게 뒷받침되는 작고 유용한 기능을 항상 추진할 것입니다.

## 마무리

- 소프트웨어의 강점은 변경할 수 있다는 것입니다. *대부분의* 소프트웨어는 시간이 지남에 따라 예측할 수 없는 방식으로 변경이 필요합니다; 그러나 미래를 예측하기 너무 어렵기 때문에 과도하게 엔지니어링하려고 하지 마세요.
- 대신 소프트웨어를 유연하게 유지하도록 해야 합니다. 소프트웨어를 변경하려면 진화할 때 리팩토링해야 하고 그렇지 않으면 엉망이 됩니다
- 좋은 테스트 스위트는 더 빠르고 덜 스트레스받는 방식으로 리팩토링하는 데 도움이 될 수 있습니다
- 좋은 단위 테스트를 작성하는 것은 설계 문제이므로 레고 브릭처럼 통합할 수 있는 의미 있는 단위가 있도록 코드를 구조화하는 것에 대해 생각하세요.
- TDD는 도착하는 미래 작업을 돕기 위해 테스트에 의해 뒷받침되는 반복적으로 잘 인수분해된 소프트웨어를 설계하도록 돕고 강제할 수 있습니다.
