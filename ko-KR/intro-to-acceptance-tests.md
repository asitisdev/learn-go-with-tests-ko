# 인수 테스트 소개

`$WORK`에서 서비스에 "그레이스풀 셧다운"이 필요해졌습니다. 그레이스풀 셧다운은 시스템이 종료되기 전에 작업을 제대로 마무리하도록 합니다. 실제 세계의 비유로는 누군가가 다음 회의로 넘어가기 전에 전화 통화를 제대로 마무리하려고 하는 것입니다. 중간에 끊어버리는 대신.

이 챕터는 HTTP 서버의 맥락에서 그레이스풀 셧다운에 대한 소개와 코드의 동작에 대한 확신을 주기 위한 "인수 테스트"를 작성하는 방법을 제공합니다.

## Kubernetes에 대한 간단한 정보

우리는 [Kubernetes](https://kubernetes.io/) (K8s)에서 소프트웨어를 실행합니다. K8s는 다양한 이유로 "파드" (실제로는 우리 소프트웨어)를 종료하며, 일반적인 이유 중 하나는 배포하려는 새 코드를 푸시할 때입니다.

K8s가 파드를 종료하려고 할 때 ["종료 라이프사이클"](https://cloud.google.com/blog/products/containers-kubernetes/kubernetes-best-practices-terminating-with-grace)을 시작하고, 그 일부로 소프트웨어에 SIGTERM 신호를 보냅니다. 이것은 K8s가 코드에 다음과 같이 말하는 것입니다:

> 스스로를 종료해야 합니다. 하던 작업을 마무리하세요. 일정 "유예 기간" 후에 `SIGKILL`을 보낼 것이고 그러면 끝입니다.

## 그레이스가 없다면

소프트웨어의 특성에 따라 `SIGTERM`을 무시하면 문제가 발생할 수 있습니다.

우리의 특정 문제는 진행 중인 HTTP 요청과 관련이 있었습니다. 자동화된 테스트가 API를 실행할 때 K8s가 파드를 중지하기로 결정하면 서버가 죽고, 테스트가 서버에서 응답을 받지 못하고, 테스트가 실패합니다.

## 그레이스가 있을 때

우리가 하고 싶은 것은 `SIGTERM`을 수신하고, 서버를 즉시 종료하는 대신:

- 더 이상 요청을 수신하지 않음
- 진행 중인 모든 요청이 완료되도록 허용
- *그런 다음* 프로세스를 종료

## 그레이스를 갖는 방법

다행히 Go에는 이미 [net/http/Server.Shutdown](https://pkg.go.dev/net/http#Server.Shutdown)으로 서버를 그레이스풀하게 종료하는 메커니즘이 있습니다.

`SIGTERM`을 처리하려면 제공하는 채널에 들어오는 신호를 보내는 [os/signal.Notify](https://pkg.go.dev/os/signal#Notify)를 사용할 수 있습니다.

## 테스트와 피드백 루프

`gracefulshutdown` 패키지를 작성할 때 올바르게 동작하는지 증명하는 단위 테스트가 있어 적극적으로 리팩토링할 수 있었습니다. 그러나 **정말로** 작동하는지 "확신"하지 못했습니다.

**엔지니어로서 수동 테스트에 불편함을 느껴야 합니다**.
지루하고, 확장되지 않고, 부정확하고, 낭비적입니다.

## 인수 테스트

이 책의 나머지 부분을 읽었다면 대부분 "단위 테스트"를 작성했을 것입니다. 단위 테스트는 두려움 없는 리팩토링, 좋은 모듈 설계, 회귀 방지, 빠른 피드백을 가능하게 하는 환상적인 도구입니다.

본질적으로 시스템의 작은 부분만 테스트합니다. 일반적으로 단위 테스트만으로는 효과적인 테스팅 전략에 *충분하지 않습니다*. 시스템이 **항상 배포 가능**하기를 원합니다. 수동 테스트에 의존할 수 없으므로 다른 종류의 테스트가 필요합니다: **인수 테스트**.

### 인수 테스트란?

인수 테스트는 일종의 "블랙박스 테스트"입니다. 때로는 "기능 테스트"라고도 합니다. 시스템 사용자가 하는 것처럼 시스템을 실행해야 합니다.

"블랙박스" 용어는 테스트 코드가 시스템의 내부에 접근할 수 없고 공용 인터페이스만 사용할 수 있다는 아이디어를 말합니다.

### 인수 테스트의 이점

- 통과하면 전체 시스템이 원하는 대로 동작한다는 것을 알 수 있습니다.
- 수동 테스트보다 더 정확하고 빠르며 노력이 덜 필요합니다.
- 잘 작성되면 시스템의 정확하고 검증된 문서 역할을 합니다.
- 모킹 없음! 모두 실제입니다.

### 단위 테스트 대비 잠재적 단점

- 작성 비용이 비쌉니다.
- 실행하는 데 더 오래 걸립니다.
- 시스템 설계에 따라 달라집니다.
- 실패하면 일반적으로 근본 원인을 알려주지 않으며 디버깅하기 어려울 수 있습니다.
- 시스템의 내부 품질에 대한 피드백을 제공하지 않습니다.
- 블랙박스 특성으로 인해 모든 시나리오를 실행하는 것이 실용적이지 않습니다.

균형 잡힌 테스팅 접근 방식은 뛰어난 리드 타임을 가진 신뢰할 수 있는 시스템에 필요하며, 이것은 보통 [테스트 피라미드](https://martinfowler.com/articles/practical-test-pyramid.html) 측면에서 설명됩니다.

## 기본 인수 테스트 작성 방법

테스트 프로그램을 살펴봅시다:

```go
func main() {
	var (
		ctx        = context.Background()
		httpServer = &http.Server{Addr: ":8080", Handler: http.HandlerFunc(acceptancetests.SlowHandler)}
		server     = gracefulshutdown.NewServer(httpServer)
	)

	if err := server.ListenAndServe(ctx); err != nil {
		log.Fatalf("uh oh, didn't shutdown gracefully, some responses may have been lost %v", err)
	}

	log.Println("shutdown gracefully! all responses were sent")
}
```

### 인수 테스트의 고수준 단계

- 프로그램 빌드
- 실행 (그리고 `8080`에서 수신 대기할 때까지 대기)
- 서버에 HTTP 요청 보내기
- 서버가 HTTP 응답을 보내기 전에 `SIGTERM` 보내기
- 여전히 응답을 받는지 확인

### 인수 테스트

```go
func TestGracefulShutdown(t *testing.T) {
	cleanup, sendInterrupt, err := acceptancetests.LaunchTestProgram(port)
	if err != nil {
		t.Fatal(err)
	}
	t.Cleanup(cleanup)

	// 종료하기 전에 서버가 작동하는지 확인
	assert.CanGet(t, url)

	// 요청을 보내고, 응답할 기회가 생기기 전에 SIGTERM을 보냄
	time.AfterFunc(50*time.Millisecond, func() {
		assert.NoError(t, sendInterrupt())
	})
	// 그레이스풀 셧다운 없이는 이것은 실패할 것임
	assert.CanGet(t, url)

	// 인터럽트 후, 서버는 종료되어야 하고 더 이상 요청이 작동하지 않음
	assert.CantGet(t, url)
}
```

설정이 캡슐화되어 테스트는 포괄적이고 동작을 설명하며 상대적으로 따라가기 쉽습니다.

Go는 인수 테스트를 작성하는 데 필요한 모든 도구를 기본 제공합니다. 인수 테스트를 빌드하기 위해 특별한 프레임워크가 *필요하지* 않습니다.

### 작은 투자로 큰 보상

이러한 테스트를 통해 독자는 예제 프로그램을 보고 예제가 *실제로* 작동한다는 확신을 가질 수 있습니다.

중요하게도, 작성자로서 패키지가 실제 환경에서 작동한다는 **빠른 피드백**과 **막대한 확신**을 얻습니다.

## 마무리

이 챕터에서는 테스팅 도구 벨트에 인수 테스트를 도입했습니다. 실제 시스템을 구축하기 시작할 때 매우 중요하며 단위 테스트의 중요한 보완입니다.

인수 테스트를 *어떻게* 작성하는지의 특성은 구축하는 시스템에 따라 다르지만 원칙은 동일합니다. 시스템을 "블랙박스"처럼 취급하세요. 웹사이트를 만들고 있다면 테스트는 사용자처럼 행동해야 하므로 [Selenium](https://www.selenium.dev/)과 같은 헤드리스 웹 브라우저를 사용하여 링크를 클릭하고 폼을 채우는 등을 수행하고 싶을 것입니다. RESTful API의 경우 클라이언트를 사용하여 HTTP 요청을 보냅니다.

### 더 복잡한 시스템으로 확장

간단하지 않은 시스템은 우리가 논의한 것과 같은 단일 프로세스 애플리케이션인 경향이 없습니다. 일반적으로 데이터베이스와 같은 다른 시스템에 의존합니다. 이러한 시나리오의 경우 테스트할 로컬 환경을 자동화해야 합니다. [docker-compose](https://docs.docker.com/compose/)와 같은 도구는 시스템을 로컬에서 실행하는 데 필요한 환경의 컨테이너를 시작하는 데 유용합니다.

### 오픈 소스 품질 향상

공유할 패키지를 작성하는 경우 패키지가 무엇을 하는지 보여주는 간단한 예제 프로그램을 만들고 자신과 잠재적 사용자에게 확신을 주기 위해 따라하기 쉬운 인수 테스트를 작성하는 데 시간을 투자하는 것이 좋습니다.
